/*
 * European Variation Archive (EVA) - Open-access database of all types of genetic
 * variation data from all species
 *
 * Copyright 2019 EMBL - European Bioinformatics Institute
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.8).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package uk.ac.ebi.eva.server.ws.ga4gh.beaconv2;

import uk.ac.ebi.eva.commons.beacon.models.BeaconAlleleRequest;
import uk.ac.ebi.eva.commons.beacon.models.BeaconAlleleResponse;
import uk.ac.ebi.eva.commons.beacon.models.Chromosome;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2019-06-18T18:08:34.969Z[GMT]")
@Api(value = "query", description = "the query API")
public interface QueryApi {

    @ApiOperation(value = "", nickname = "getBeaconAlleleResponse", notes = "Get response to a beacon query for allele information.", response = BeaconAlleleResponse.class, responseContainer = "List", tags={  })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successful operation", response = BeaconAlleleResponse.class, responseContainer = "List"),
        @ApiResponse(code = 400, message = "Bad request (e.g. missing mandatory parameter)", response = BeaconAlleleResponse.class),
        @ApiResponse(code = 401, message = "Unauthorised (e.g. when an unauthenticated user tries to access a protected resource)", response = BeaconAlleleResponse.class),
        @ApiResponse(code = 403, message = "Forbidden (e.g. the resource is protected for all users or the user is authenticated but s/he is not granted for this resource)", response = BeaconAlleleResponse.class) })
    @RequestMapping(value = "/query",
        produces = { "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<List<BeaconAlleleResponse>> getBeaconAlleleResponse(@NotNull @ApiParam(value = "Reference name (chromosome). Accepting values 1-22, X, Y, MT.", required = true) @Valid @RequestParam(value = "referenceName", required = true) Chromosome referenceName,@NotNull @Pattern(regexp="^([ACGT]+|N)$") @ApiParam(value = "Reference bases for this variant (starting from `start`). Accepted values: [ACGT]* When querying for variants without specific base alterations (e.g. imprecise structural variants with separate variant_type as well as start_min & end_min ... parameters), the use of a single \"N\" value is required. ", required = true) @Valid @RequestParam(value = "referenceBases", required = true) String referenceBases,@NotNull @ApiParam(value = "Assembly identifier (GRC notation, e.g. GRCh37).", required = true) @Valid @RequestParam(value = "assemblyId", required = true) String assemblyId,@Min(0L)@ApiParam(value = "Precise start coordinate position, allele locus (0-based, inclusive). * start only:   - for single positions, e.g. the start of a specified sequence alteration where the size is given through the specified alternateBases   - typical use are queries for SNV and small InDels   - the use of \"start\" without an \"end\" parameter requires the use of \"referenceBases\" * start and end:   - special use case for exactly determined structural changes ", allowableValues = "") @Valid @RequestParam(value = "start", required = false) Long start,@Min(0L)@ApiParam(value = "Minimum start coordinate * startMin + startMax + endMin + endMax   - for querying imprecise positions (e.g. identifying all structural variants starting anywhere between startMin <-> startMax, and ending anywhere between endMin <-> endMax)   - single or double sided precise matches can be achieved by setting startMin = startMax XOR endMin = endMax ", allowableValues = "") @Valid @RequestParam(value = "startMin", required = false) Long startMin,@Min(0L)@ApiParam(value = "Maximum start coordinate. See startMin. ", allowableValues = "") @Valid @RequestParam(value = "startMax", required = false) Long startMax,@Min(0L)@ApiParam(value = "Precise end coordinate (0-based, exclusive). See start. ", allowableValues = "") @Valid @RequestParam(value = "end", required = false) Long end,@Min(0L)@ApiParam(value = "Minimum end coordinate. See startMin. ", allowableValues = "") @Valid @RequestParam(value = "endMin", required = false) Long endMin,@Min(0L)@ApiParam(value = "Maximum end coordinate. See startMin. ", allowableValues = "") @Valid @RequestParam(value = "endMax", required = false) Long endMax,@Pattern(regexp="^([ACGT]+|N)$") @ApiParam(value = "The bases that appear instead of the reference bases. Accepted values: [ACGT]* or N. Symbolic ALT alleles (DEL, INS, DUP, INV, CNV, DUP:TANDEM, DEL:ME, INS:ME) will be represented in `variantType`. Optional: either `alternateBases` or `variantType` is required. ") @Valid @RequestParam(value = "alternateBases", required = false) String alternateBases,@ApiParam(value = "The `variantType` is used to denote e.g. structural variants. Examples: * DUP: duplication of sequence following `start`; not necessarily in situ * DEL: deletion of sequence following `start` Optional: either `alternateBases` or `variantType` is required. ") @Valid @RequestParam(value = "variantType", required = false) String variantType,@ApiParam(value = "Identifiers of datasets, as defined in \"BeaconDataset\". If this field is null/not specified, all datasets should be queried.") @Valid @RequestParam(value = "datasetIds", required = false) List<String> datasetIds,@ApiParam(value = "Indicator of whether responses for individual datasets (datasetAlleleResponses) should be included in the response (BeaconAlleleResponse) to this request or not. If null (not specified), the default value of NONE is assumed. ", allowableValues = "ALL, HIT, MISS, NONE") @Valid @RequestParam(value = "includeDatasetResponses", required = false) String includeDatasetResponses);


    @ApiOperation(value = "", nickname = "postBeaconAlleleResponse", notes = "Gets response to a beacon query for allele information.", response = BeaconAlleleResponse.class, responseContainer = "List", tags={  })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successful operation", response = BeaconAlleleResponse.class, responseContainer = "List"),
        @ApiResponse(code = 400, message = "Bad request (e.g. missing mandatory parameter)", response = BeaconAlleleResponse.class),
        @ApiResponse(code = 401, message = "Unauthorised (e.g. when an unauthenticated user tries to access a protected resource)", response = BeaconAlleleResponse.class),
        @ApiResponse(code = 403, message = "Forbidden (e.g. the resource is protected for all users or the user is authenticated but s/he is not granted for this resource)", response = BeaconAlleleResponse.class) })
    @RequestMapping(value = "/query",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity<List<BeaconAlleleResponse>> postBeaconAlleleResponse(@ApiParam(value = "" ,required=true )  @Valid @RequestBody BeaconAlleleRequest body);

}
